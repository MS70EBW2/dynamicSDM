split_grid <- raster::setValues(split_grid,  1:raster::ncell(split_grid)) #fill grid squares with numerical value to create label
split_grid <-raster::crop(split_grid,raster::extent(spatial.layer))
split2<-raster::extract(split_grid, occ.data.points)  # Extract grid cell number that each occurrence record belongs too.
occ.data$split2<-split2}
cols <-c(if(exists("split1")) "split1",if(exists("split2"))"split2",if(exists("temporal.block.2"))temporal.block.2) # Set column names depending on methods employed
if(length(cols)>1){occ.data$ID_FOR_BLOCKING<-as.numeric(as.factor(apply(occ.data[ , cols ] , 1 , paste , collapse = "-" )))} ## Create unique ID based on the spatial.layer category,spatial.split.degrees cell number and temporal.block
if(length(cols)==1){occ.data$ID_FOR_BLOCKING<-as.numeric(as.factor(occ.data[ , cols ]))} ## Create unique ID based on one of the spatial.layer category,spatial.split.degrees cell number or temporal.block
blockdata<-as.data.frame(unique(occ.data$ID_FOR_BLOCKING)) # List all unique IDs of occurrence records derived from the spatial and temporal categories assigned
# For each explanatory variable specified, aggregate the data to take the mean of each ID for each variable. These average will be used to assign records with each unique ID to a block
for (n in 1:length(vars.to.block.by)){blockdata<-cbind(blockdata, aggregate(as.formula(paste(paste(c(vars.to.block.by[n],"ID_FOR_BLOCKING"), collapse="~"),sep = "")),data=occ.data,FUN='mean')[,2])}
colnames(blockdata)<-c("ID_FOR_BLOCKING",vars.to.block.by)
#Check minimum number of unique IDs met for the number of blocks (n.blocks) desired.
if(nrow(blockdata)<n.blocks){stop("Not enough individual sampling units for given number of blocks. Please try adding spatial.split.degrees for large classifications or more temporal split categories if appropriate.")}
groupings<-list() # Create empty list object to store random groupings of sampling units
results<-NULL # Create empty vector to store variance of mean and range of each variable for random groupins
for (x in 1:iterations){
shuff<- blockdata[sample(1:nrow(blockdata)), ] # Randomly shuffle sampling units
groups<-split(shuff, cut(1:nrow(shuff), n.blocks, FALSE)) # Split shuffled datasets into roughly equal block groupings
groupings[[x]]<-groups # Bind random block grouping to list.
variances<-NULL # Empty vector to bind the variance of means between groups for each variable to
for (y in 2:ncol(blockdata)){ # Iterates through each variable
mean <- lapply(groups,function(df_inlist) {base::mean((df_inlist[,y]))}) # Calculates the mean for each block
variance.mean<-var(unlist(mean)) # Calculate the variance in means across blocks (we want to minimise this value when blocking)
range <- lapply(groups,function(df_inlist) {(max(df_inlist[,y])-min(df_inlist[,y]))})
variance.range<-var(unlist(range))
variances<-rbind(variances,variance.mean,variance.range)}
results<-rbind(results,t(variances))} # Record variances in mean and range for each variable for this random blocking
results<-as.data.frame(results)
results<-as.data.frame(sapply(results, function(x){(x-min(x))/(max(x)-min(x))}))   # Scale variance of mean and range for each variable so that no one variable has more weighting than another when minimising mean and variance between blocks
optimal.blocking<-groupings[[which.min(rowSums(results))]] # Select block group with minimum variance in mean and range across all variables.
blocks<-lapply(optimal.blocking,function(x){x[,"ID_FOR_BLOCKING"]}) # Extract sample units within each block
for (b in 1:n.blocks){occ.data[occ.data$ID_FOR_BLOCKING %in% c(as.numeric(as.character(blocks[[b]]))), "block"]<-b} # Add block number to each occurrence record in data.frame
occ.data.save$BLOCK.CATS<-occ.data$block # Add block numbers to original provided data frame and return to user
return(occ.data.save)}
spatiotemp_block(occ.data = sample_model_data,spatial.layer = biome_layer,spatial.split.degrees=3,vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=10)
library(testthat)
test_that("Doesn't error with only spatial blocking", {
df<-spatiotemp_block(occ.data = sample_model_data,spatial.layer = biome_layer,spatial.split.degrees=3,vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=10))})
df<-spatiotemp_block(occ.data = sample_model_data,spatial.layer = biome_layer,spatial.split.degrees=3,vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=10)
unique(df$BLOCK.CATS)
length(unique(df$BLOCK.CATS))
test_that("Doesn't error with only spatial blocking", {
df<-spatiotemp_block(occ.data = sample_model_data,spatial.layer = biome_layer,spatial.split.degrees=3,vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=10)
expect_equal(length(unique(df$BLOCK.CATS)),10)})
n<-sample(1:10,1)
n<-as.numeric(sample(1:10,1))
n
test_that("Doesn't error with only spatial blocking", {
n<-as.numeric(sample(1:10,1))
df<-spatiotemp_block(occ.data = sample_model_data,spatial.layer = biome_layer,spatial.split.degrees=3,vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=n)
expect_equal(length(unique(df$BLOCK.CATS)),n)})
test_that("Doesn't error with spatial and temporal blocking", {
n<-as.numeric(sample(1:10,1))
df<-spatiotemp_block(occ.data = sample_model_data,spatial.layer = biome_layer,spatial.split.degrees=3,temporal.block=c("month"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=n)
expect_equal(length(unique(df$BLOCK.CATS)),n)})
test_that("Errors if too many blocks expected", {
expect_error(spatiotemp_block(occ.data = sample_model_data,spatial.layer = biome_layer,spatial.split.degrees=3,temporal.block=c("month"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=100000))})
data("sample_model_data")
sample_model_data<-dplyr::sample_n(sample_model_data,8000)
data("biome_layer")
test_that("stops if no occ.data provided", {
expect_error(spatiotemp_block(spatial.layer=biome_layer,spatial.split.degrees=3,temporal.block=c("month"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=10))})
test_that("stops if no vars.to.block.by provided", {
expect_error(spatiotemp_block(occ.data = sample_model_data,spatial.layer=biome_layer,spatial.split.degrees=3,temporal.block=c("month"),n.blocks=10))})
test_that("stops if spatial.layer not class RasterLayer", {
expect_error(spatiotemp_block(occ.data = sample_model_data,spatial.layer=c(0,20,-20,30),spatial.split.degrees=3,temporal.block=c("month"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=10))})
test_that("stops if spatial.split.degrees not class numeric", {
expect_error(spatiotemp_block(occ.data = sample_model_data,spatial.layer=biome_layer,spatial.split.degrees="three",temporal.block=c("month"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=10))})
test_that("stops if spatial.layer given but no spatial.split.degrees", {
expect_error(spatiotemp_block(occ.data = sample_model_data,spatial.layer=biome_layer,temporal.block=c("month"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=10))})
test_that("stops if temporal.block not accepted", {
expect_error(spatiotemp_block(occ.data = sample_model_data,spatial.layer=biome_layer,spatial.split.degrees=3,temporal.block=c("decadal"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=10))})
test_that("Only temporal blocking by one level, results in correct number of unique blocking categories", {
n<-as.numeric(sample(1:10,1))
df<-spatiotemp_block(occ.data = sample_model_data,temporal.block=c("month"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=n)
expect_equal(length(unique(df$BLOCK.CATS)),n)})
test_that("Doesn't error with only temporal blocking by two feature", {
n<-as.numeric(sample(1:10,1))
df<-spatiotemp_block(occ.data = sample_model_data,temporal.block=c("quarter","year"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=n)
expect_equal(length(unique(df$BLOCK.CATS)),n)})
test_that("Only spatial blocking, results in correct number of unique blocking categories", {
n<-as.numeric(sample(1:10,1))
df<-spatiotemp_block(occ.data = sample_model_data,spatial.layer = biome_layer,spatial.split.degrees=3,vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=n)
expect_equal(length(unique(df$BLOCK.CATS)),n)})
test_that("Both spatial and temporal blocking, results in correct number of unique blocking categories", {
n<-as.numeric(sample(1:10,1))
df<-spatiotemp_block(occ.data = sample_model_data,spatial.layer = biome_layer,spatial.split.degrees=3,temporal.block=c("month"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=n)
expect_equal(length(unique(df$BLOCK.CATS)),n)})
test_that("Errors if too many blocks expected", {
expect_error(spatiotemp_block(occ.data = sample_model_data,spatial.layer = biome_layer,spatial.split.degrees=3,temporal.block=c("month"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=100000))})
spatiotemp_block<-function(occ.data,vars.to.block.by,spatial.layer=NULL,spatial.split.degrees=NULL,temporal.block=NULL,n.blocks=10,iterations=10000){
occ.data.save<-occ.data # Save original occ.data to return to used with added block column at end
if (missing(spatial.layer)){message("spatial.layer is missing. No blocking by spatial features.")}
if (missing(temporal.block)){message("temporal.block is missing. No blocking by temporal features.")}
if(!missing(temporal.block)){
temporal.block.2<-match.arg(temporal.block,choices=c("day","month","year","quarter"),several.ok = T)
if(any(temporal.block.2=="quarter")){occ.data$quarter <- cut(occ.data$month, breaks = c(0, 3, 6,9, 12),labels = c("first", "second", "third","fourth"))}} # Split data into quarters fo the year by month
if (!missing(spatial.layer)){
if(!class(spatial.layer)=="RasterLayer"){stop("spatial.layer must be of class RasterLayer")}
if(!class(spatial.split.degrees)=="numeric"){stop("spatial.split.degrees must be of class numeric")}
occ.data.points<- sp::SpatialPointsDataFrame(data = occ.data, coords = cbind(occ.data$x, occ.data$y),
proj4string = terra::crs("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"))
### Assign occurrence points value from the categorical RasterLayer provided by extracting at record co-ordinates
split1<-raster::extract(spatial.layer, occ.data.points) #For each record co-ordinate extract spatial.layer value from given RasterLayer
occ.data$split1<-split1
### Assign occurrence points value from a RasterLayer at given spatial.split.degrees to spatially split large categories of previous categorical RasterLayer
split_grid<-raster::raster(raster::extent(spatial.layer),crs=raster::crs(spatial.layer)) # Create another grid with same spatial extent and CRS as spatial.layer
raster::res(split_grid)<-spatial.split.degrees  # Set the grid's resolution as specified by the user
split_grid <- raster::setValues(split_grid,  1:raster::ncell(split_grid)) #fill grid squares with numerical value to create label
split_grid <-raster::crop(split_grid,raster::extent(spatial.layer))
split2<-raster::extract(split_grid, occ.data.points)  # Extract grid cell number that each occurrence record belongs too.
occ.data$split2<-split2}
cols <-c(if(exists("split1")) "split1",if(exists("split2"))"split2",if(exists("temporal.block.2"))temporal.block.2) # Set column names depending on methods employed
if(length(cols)>1){occ.data$ID_FOR_BLOCKING<-as.numeric(as.factor(apply(occ.data[ , cols ] , 1 , paste , collapse = "-" )))} ## Create unique ID based on the spatial.layer category,spatial.split.degrees cell number and temporal.block
if(length(cols)==1){occ.data$ID_FOR_BLOCKING<-as.numeric(as.factor(occ.data[ , cols ]))} ## Create unique ID based on one of the spatial.layer category,spatial.split.degrees cell number or temporal.block
blockdata<-as.data.frame(unique(occ.data$ID_FOR_BLOCKING)) # List all unique IDs of occurrence records derived from the spatial and temporal categories assigned
# For each explanatory variable specified, aggregate the data to take the mean of each ID for each variable. These average will be used to assign records with each unique ID to a block
for (n in 1:length(vars.to.block.by)){blockdata<-cbind(blockdata, aggregate(as.formula(paste(paste(c(vars.to.block.by[n],"ID_FOR_BLOCKING"), collapse="~"),sep = "")),data=occ.data,FUN='mean')[,2])}
colnames(blockdata)<-c("ID_FOR_BLOCKING",vars.to.block.by)
#Check minimum number of unique IDs met for the number of blocks (n.blocks) desired.
if(nrow(blockdata)<n.blocks){stop("Not enough individual sampling units for given number of blocks. Please try adding spatial.split.degrees for large classifications or more temporal split categories if appropriate.")}
groupings<-list() # Create empty list object to store random groupings of sampling units
results<-NULL # Create empty vector to store variance of mean and range of each variable for random groupins
for (x in 1:iterations){
shuff<- blockdata[sample(1:nrow(blockdata)), ] # Randomly shuffle sampling units
groups<-split(shuff, cut(1:nrow(shuff), n.blocks, FALSE)) # Split shuffled datasets into roughly equal block groupings
groupings[[x]]<-groups # Bind random block grouping to list.
variances<-NULL # Empty vector to bind the variance of means between groups for each variable to
for (y in 2:ncol(blockdata)){ # Iterates through each variable
mean <- lapply(groups,function(df_inlist) {base::mean((df_inlist[,y]))}) # Calculates the mean for each block
variance.mean<-var(unlist(mean)) # Calculate the variance in means across blocks (we want to minimise this value when blocking)
range <- lapply(groups,function(df_inlist) {(max(df_inlist[,y])-min(df_inlist[,y]))})
variance.range<-var(unlist(range))
variances<-rbind(variances,variance.mean,variance.range)}
results<-rbind(results,t(variances))} # Record variances in mean and range for each variable for this random blocking
results<-as.data.frame(results)
results<-as.data.frame(sapply(results, function(x){(x-min(x))/(max(x)-min(x))}))   # Scale variance of mean and range for each variable so that no one variable has more weighting than another when minimising mean and variance between blocks
optimal.blocking<-groupings[[which.min(rowSums(results))]] # Select block group with minimum variance in mean and range across all variables.
blocks<-lapply(optimal.blocking,function(x){x[,"ID_FOR_BLOCKING"]}) # Extract sample units within each block
for (b in 1:n.blocks){occ.data[occ.data$ID_FOR_BLOCKING %in% c(as.numeric(as.character(blocks[[b]]))), "block"]<-b} # Add block number to each occurrence record in data.frame
occ.data.save$BLOCK.CATS<-occ.data$block # Add block numbers to original provided data frame and return to user
return(occ.data.save)}
df<-spatiotemp_block(occ.data = sample_model_data,spatial.layer = biome_layer,spatial.split.degrees=3,vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=n)
df
data("sample_occ_data")
numeric<-c(20,36,-35,-12)
occ.data=sample_occ_data
n.pseudoabs=10
temporal.method="buffer"
spatial.method="random"
spatial.ext=numeric
temporal.buffer=c(14,30)
# Match argument to available options
temporal.method<-match.arg(arg = temporal.method, choices = c( "buffer","random"))
spatial.method<-match.arg(arg = spatial.method, choices = c( "buffer","random"))
### Numeric vector to polygon
if(class(spatial.ext)=="numeric" && length(spatial.ext)==4){spatial.ext<-as(raster::extent(spatial.ext[1],spatial.ext[2],spatial.ext[3],spatial.ext[4]), 'SpatialPolygons')}
### Extent object to polygon
if(class(spatial.ext)=="Extent"){spatial.ext<-as(spatial.ext, 'SpatialPolygons')}
### RasterLayer object to polygon
if(class(spatial.ext)=="RasterLayer"){spatial.ext<-as(raster::extent(spatial.ext), 'SpatialPolygons')}
pseudoabs_coords<-as.data.frame(sp::spsample(spatial.ext ,type='random', n=n.pseudoabs,iter=30))} ## Randomly generate specified number of pseudo-absence co-ordinates within extent polygon
pseudoabs_coords<-as.data.frame(sp::spsample(spatial.ext ,type='random', n=n.pseudoabs,iter=30))
## Calculate the number of pseudo-absences to generate in buffer from each occurrence record to meet or slightly exceed the required amount
value<-ceiling(n.pseudoabs/nrow(occ.data))
first.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[1],step_dg = 60,output = "sp")
second.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[2],step_dg = 60,output = "sp")
spatial.method="buffer"
spatial.buffer=c(100,1000)
## Calculate the number of pseudo-absences to generate in buffer from each occurrence record to meet or slightly exceed the required amount
value<-ceiling(n.pseudoabs/nrow(occ.data))
first.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[1],step_dg = 60,output = "sp")
install.packages(spatialEco)
install.packages("spatialEco")
geobuffer_pts
geobuffer::geobuffer_pts
spob<-sp::SpatialPoints(data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])))
rgeos::gBuffer(spob, byid=FALSE, id=NULL, width=1.0, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0)
first.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[1],step_dg = 60,output = "sp")
plot(first.buff)
spatial.buffer
second.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[2],step_dg = 60,output = "sp")
plot(second.buff)
# Create buffer shapefiles for given buffer min and max size from each occurrence record co-ordinates as specified by the user
spatial.buffer<-c(100000,1000000)
first.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[1],step_dg = 60,output = "sp")
plot(first.buff)
rgeos::gBuffer(spob, byid=FALSE, id=NULL, width=100000, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0)
plot(rgeos::gBuffer(spob, byid=FALSE, id=NULL, width=100000, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0))
rgeos::gBuffer(spob, byid=TRUE, id=TRUE, width=100000, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0)
rgeos::gBuffer(spob, byid=TRUE,  width=100000, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0)
first.buff
first.buff2<-rgeos::gBuffer(spob, byid=TRUE,  width=100000, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0)
plot(first.buff2)
plot(first.buff)
spob<-sp::SpatialPoints(data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])))
first.buff2<-rgeos::gBuffer(spob, byid=TRUE,  width=100000, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0)
plot(first.buff2)
spob<-sp::SpatialPoints(data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])))
first.buff2<-rgeos::gBuffer(spob, byid=TRUE,  width=100000, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0)
first.buff2
first.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[1],step_dg = 60,output = "sp")
first.buff
first.buff2<-rgeos::gBuffer(spob, byid=TRUE,  width=100000)
first.buff2
spob
spob<-sp::SpatialPoints(data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])))
spob <- sp::spTransform(spob, CRS("+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"))
first.buff2<-rgeos::gBuffer(spob, byid=TRUE,  width=100000)
spob<-sp::SpatialPoints(data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])))
spob<-sp::SpatialPoints(data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])))
c(occ.data[,"x"])
sites <- data.frame(Lon = c(occ.data[,"x"]), Lat = c(occ.data[,"y"]))
coordinates(sites) <- ~Lon + Lat
proj4string(sites) <- CRS("+proj=longlat")
sites <- spTransform(sites, CRS = CRS("+init=epsg:3857"))
spTransform
first.buff2<-rgeos::gBuffer(spob, byid=TRUE,  width=100000)
first.buff2<-rgeos::gBuffer(sites, byid=TRUE,  width=100000)
plot(first.buff2)
plot(first.buff)
first.buff2
first.buff
first.buff
first.buff2
install.packages("rangemap")
first.buff3<-rangemap::geobuffer_points(sites,radius=100000,by_point = T)
sites <- matrix(Lon = c(occ.data[,"x"]), Lat = c(occ.data[,"y"]))
sites <- matrix(occ.data[,"x"], occ.data[,"y"])
sites <- matrix(as.data.frame(occ.data[,"x"], occ.data[,"y"]))
sites <- as.matrix(as.data.frame(occ.data[,"x"], occ.data[,"y"]))
coords <- occ.data[, c("x","y"]
first.buff3<-rangemap::geobuffer_points(sites,radius=100000,by_point = T)
first.buff2<-rgeos::gBuffer(sites, byid=TRUE,  width=100000)
plot(first.buff)
rangemap::geobuffer_points()
second.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[2],step_dg = 60,output = "sp")
raster::crs(second.buff)<-NA
raster::crs(first.buff)<-NA
pseudoabs_coords=NULL ## Create vector for binding pseudoabsence co-ordinates too
for (x in 1:nrow(occ.data)){pseudoabs_coords<-rbind(pseudoabs_coords,sp::coordinates(sp::spsample(rgeos::gDifference(second.buff[x], first.buff[x]),type='random', n=value,iter=30)))}
colnames(pseudoabs_coords)<-c("x","y")}# Set pseudoabsence co-ordinate column names as "x" for co-ordinate longitude and "y" for co-ordinate latitude
## Buffered generation of pseudo-absence dates
if(temporal.method=="buffer"){
### Check that if temporal buffer chosen, a temporal buffer of appropriate class, length and order is provided
if (missing(temporal.buffer)){stop("No temporal.buffer specified specified to generate pseudo-absence dates within.")}
if(!class(temporal.buffer)=="numeric"){stop("temporal.buffer must be numeric")}
if(!length(temporal.buffer)==2){stop("temporal.buffer must be length(2) representing the buffer to generate coords in")}
if(temporal.buffer[1]-temporal.buffer[2]>0){stop("Second temporal.buffer must be higher than first")}
## Calculate the number of pseudo-absences to generate in buffer from each occurrence record to meet or slightly exceed the required amount
value<-ceiling(n.pseudoabs/nrow(occ.data))
## Generate list of max temporal buffer distance (specified by user) away from each occurrence record date
date1<-as.Date(with(occ.data, paste(year, month, day,sep="-")), "%Y-%m-%d")+ temporal.buffer[2]
pseudoabs_dates=date1[1] ## Create "Date" vector for binding pseudoabsence dates too
for (x in 1:length(date1)){pseudoabs_dates<-c(pseudoabs_dates,as.Date(date1[x]- sample(c(0:temporal.buffer[1],0:(-temporal.buffer[1])), value,replace=T)))} # For each occ.data record date, randomly select the calculated number of dates (object "value") within the buffer period
pseudoabs_dates<-pseudoabs_dates[2:length(pseudoabs_dates)] ## Remove first one as used to set vector class as "Date"
pseudoabs_dates<-as.data.frame(pseudoabs_dates)
pseudoabs_dates<-tidyr::separate(pseudoabs_dates, "pseudoabs_dates", c("year", "month", "day"), sep = "-")  }
# If either method "buffer" is chosen, there may be slightly more generated than specified by n.pseudoabs, so randomly select this amount from generated lists
if(temporal.method=="buffer" && spatial.method=="buffer"){
pseudo.df<-dplyr::sample_n(as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates)),n.pseudoabs)} ## Keeps co-ordinates and dates relevant to same occurrence record together before randomly selecting
if(temporal.method=="buffer" && spatial.method=="random"){
pseudoabs_dates<-dplyr::sample_n(as.data.frame(pseudoabs_dates),n.pseudoabs) ## As ceiling used to calculate maximum number of points in buffer to generate to meet specified number of pseudo.abs, this may be slightly too many. This randomyl selects the exact number specified by the user
pseudo.df<-as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates))}
if(temporal.method=="random" && spatial.method=="buffer"){
pseudoabs_coords<-dplyr::sample_n(as.data.frame(pseudoabs_coords),n.pseudoabs)
pseudo.df<-as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates))}
if(temporal.method=="random" && spatial.method=="random"){
pseudo.df<-as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates))}
return(pseudo.df)}
coords <- occ.data[, c("x","y")]
coords
first.buff3<-rangemap::geobuffer_points(coords,radius=100000,by_point = T)
coords <- occ.data[, c("x","y")]
first.buff3<-rangemap::geobuffer_points(coords,radius=100000,by_point = T)
plot(first.buff)
plot(first.buff3)
first.buff3
first.buff
spatiotemp_pseudoabs<-function(spatial.method,temporal.method,occ.data=NULL,spatial.ext=NULL,temporal.ext=NULL,spatial.buffer=NULL,temporal.buffer=NULL,n.pseudoabs=100){
if(!class(n.pseudoabs)=="numeric"){stop("n.pseudoabs should be a numeric value")}
# Match argument to available options
temporal.method<-match.arg(arg = temporal.method, choices = c( "buffer","random"))
spatial.method<-match.arg(arg = spatial.method, choices = c( "buffer","random"))
## Random generation of pseudo-absence co-ordinates
if(spatial.method=="random"){
### Check that if spatial random chosen, a spatial extent of appropriate class, length and order is provided
if (missing(spatial.ext)){stop("No spatial.ext specified to randomly generate pseudo-absence co-ordinates within.")}
if(!any(class(spatial.ext)==c("numeric","Extent","RasterLayer","Polygon"))){
stop("spatial.ext must be of class numeric, Extent, RasterLayer or Polygon")}
### Numeric vector to polygon
if(class(spatial.ext)=="numeric" && length(spatial.ext)==4){spatial.ext<-as(raster::extent(spatial.ext[1],spatial.ext[2],spatial.ext[3],spatial.ext[4]), 'SpatialPolygons')}
### Extent object to polygon
if(class(spatial.ext)=="Extent"){spatial.ext<-as(spatial.ext, 'SpatialPolygons')}
### RasterLayer object to polygon
if(class(spatial.ext)=="RasterLayer"){spatial.ext<-as(raster::extent(spatial.ext), 'SpatialPolygons')}
pseudoabs_coords<-as.data.frame(sp::spsample(spatial.ext ,type='random', n=n.pseudoabs,iter=30))} ## Randomly generate specified number of pseudo-absence co-ordinates within extent polygon
## Random generation of pseudo-absence dates
if(temporal.method=="random"){
### Check that if temporal random chosen, a temporal extent of appropriate class, length and order is provided
if (missing(temporal.ext)){stop("No temporal.ext specified to randomly generate pseudo-absence dates within.")}
if(!class(temporal.ext)=="character"){stop("temporal.ext must be character vector of length 2")}
if(!length(temporal.ext)==2){stop("two dates must be provides for temporal extent")}
tryCatch({dates<-as.Date(temporal.ext)},error=function(e){stop("Both dates invalid given in temporal.ext. Ensure format YYYY-MM-DD")})  ## Check dates are valid
if(any(is.na(dates))){stop("Invalid date given in temporal.ext. Ensure format YYYY-MM-DD")}
firstdate<-as.Date(temporal.ext)[1]
seconddate<-as.Date(temporal.ext)[2]
if(firstdate-seconddate>0){stop("First date must be before second date")} # Check dates are in order
pseudoabs_dates<- firstdate + sample(1:(seconddate-firstdate), size=n.pseudoabs,replace=T) ## Randomly generate dates within given extent
pseudoabs_dates<-tidyr::separate(as.data.frame(pseudoabs_dates), "pseudoabs_dates", c("year", "month", "day"), sep = "-")} ## Split dates into year, month and day columns for returned dataframe
## Buffered generation of pseudo-absence co-ordinates
if(spatial.method=="buffer"){
### Check that if spatial buffer chosen, a temporal buffer of appropriate class, length and order is provided
if(missing(spatial.buffer)){stop("No spatial.buffer specified to generate pseudo-absence co-ordinates within.")}
if(!class(spatial.buffer)=="numeric"){stop("spatial.buffer must be numeric")}
if(!length(spatial.buffer)==2){stop("spatial.buffer must be length  2 representing the buffer in metres to generate coords in. e.g. c(500,3000) buffer of 500m to 3000m")}
if(spatial.buffer[1]-spatial.buffer[2]>0){stop("Second spatial.buffer must be further away than first")}
## Calculate the number of pseudo-absences to generate in buffer from each occurrence record to meet or slightly exceed the required amount
value<-ceiling(n.pseudoabs/nrow(occ.data))
# Create buffer shapefiles for given buffer min and max size from each occurrence record co-ordinates as specified by the user
spatial.buffer<-c(100000,1000000)
first.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[1],step_dg = 60,output = "sp")
coords <- occ.data[, c("x","y")]
first.buff3<-rangemap::geobuffer_points(coords,radius=100000,by_point = T)
second.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[2],step_dg = 60,output = "sp")
raster::crs(second.buff)<-NA
raster::crs(first.buff)<-NA
pseudoabs_coords=NULL ## Create vector for binding pseudoabsence co-ordinates too
for (x in 1:nrow(occ.data)){pseudoabs_coords<-rbind(pseudoabs_coords,sp::coordinates(sp::spsample(rgeos::gDifference(second.buff[x], first.buff[x]),type='random', n=value,iter=30)))}
colnames(pseudoabs_coords)<-c("x","y")}# Set pseudoabsence co-ordinate column names as "x" for co-ordinate longitude and "y" for co-ordinate latitude
## Buffered generation of pseudo-absence dates
if(temporal.method=="buffer"){
### Check that if temporal buffer chosen, a temporal buffer of appropriate class, length and order is provided
if (missing(temporal.buffer)){stop("No temporal.buffer specified specified to generate pseudo-absence dates within.")}
if(!class(temporal.buffer)=="numeric"){stop("temporal.buffer must be numeric")}
if(!length(temporal.buffer)==2){stop("temporal.buffer must be length(2) representing the buffer to generate coords in")}
if(temporal.buffer[1]-temporal.buffer[2]>0){stop("Second temporal.buffer must be higher than first")}
## Calculate the number of pseudo-absences to generate in buffer from each occurrence record to meet or slightly exceed the required amount
value<-ceiling(n.pseudoabs/nrow(occ.data))
## Generate list of max temporal buffer distance (specified by user) away from each occurrence record date
date1<-as.Date(with(occ.data, paste(year, month, day,sep="-")), "%Y-%m-%d")+ temporal.buffer[2]
pseudoabs_dates=date1[1] ## Create "Date" vector for binding pseudoabsence dates too
for (x in 1:length(date1)){pseudoabs_dates<-c(pseudoabs_dates,as.Date(date1[x]- sample(c(0:temporal.buffer[1],0:(-temporal.buffer[1])), value,replace=T)))} # For each occ.data record date, randomly select the calculated number of dates (object "value") within the buffer period
pseudoabs_dates<-pseudoabs_dates[2:length(pseudoabs_dates)] ## Remove first one as used to set vector class as "Date"
pseudoabs_dates<-as.data.frame(pseudoabs_dates)
pseudoabs_dates<-tidyr::separate(pseudoabs_dates, "pseudoabs_dates", c("year", "month", "day"), sep = "-")  }
# If either method "buffer" is chosen, there may be slightly more generated than specified by n.pseudoabs, so randomly select this amount from generated lists
if(temporal.method=="buffer" && spatial.method=="buffer"){
pseudo.df<-dplyr::sample_n(as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates)),n.pseudoabs)} ## Keeps co-ordinates and dates relevant to same occurrence record together before randomly selecting
if(temporal.method=="buffer" && spatial.method=="random"){
pseudoabs_dates<-dplyr::sample_n(as.data.frame(pseudoabs_dates),n.pseudoabs) ## As ceiling used to calculate maximum number of points in buffer to generate to meet specified number of pseudo.abs, this may be slightly too many. This randomyl selects the exact number specified by the user
pseudo.df<-as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates))}
if(temporal.method=="random" && spatial.method=="buffer"){
pseudoabs_coords<-dplyr::sample_n(as.data.frame(pseudoabs_coords),n.pseudoabs)
pseudo.df<-as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates))}
if(temporal.method=="random" && spatial.method=="random"){
pseudo.df<-as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates))}
return(pseudo.df)}
test_that("Success if spatial extent numeric", {
numeric<-c(20,36,-35,-12)
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="buffer",spatial.method="random",spatial.ext=numeric,temporal.buffer=c(14,30))
expect_equal(class(results),"data.frame")})
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="buffer",spatial.method="random",spatial.ext=numeric,temporal.buffer=c(14,30))
results
test_that("Success if spatial extent extent", {
Extent<-raster::extent(c(20,36,-35,-12))
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="buffer",spatial.method="random",spatial.ext=Extent,temporal.buffer=c(14,30))
expect_equal(class(results),"data.frame")})
test_that("Success if spatial extent raster", {
raster<-raster::raster(raster::extent(c(20,36,-35,-12)))
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="buffer",spatial.method="random",spatial.ext=raster,temporal.buffer=c(14,30))
expect_equal(class(results),"data.frame")})
test_that("Success if spatial extent polygon", {
polygon<-sp::Polygon(cbind(c(20,12,36,36),c(-35,-12,-35,-12)))
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="buffer",spatial.method="random",spatial.ext=polygon,temporal.buffer=c(14,30))
expect_equal(class(results),"data.frame")})
test_that("Success if temporal method random and spatial buffer", {
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
expect_equal(class(results),"data.frame")})
test_that("Success if temporal method random and spatial random, n.pseudoabs default", {
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
expect_equal(class(results),"data.frame")})
devtools::load_all()
devtools::load_all()
devtools::document()
install.packages("renv")
renv::dependencies(path="C:/Users/eerdo/Documents/GitHub/dynamicSDM/R")
r<-renv::dependencies(path="C:/Users/eerdo/Documents/GitHub/dynamicSDM/R")
r
unique(r)
r$Package
unique(r$Package)
sort(unique(r$Package))
rgee::ee_check_credentials()
rgee::ee_users()
d<-rgee::ee_check_credentials()
(rgee::ee_check_credentials())==F
user.email<-as.character(gargle::gargle_oauth_sitrep()$email)
gargle::gargle_oauth_sitrep()
b<-gargle::gargle_oauth_sitrep()
View(b)
googledrive::drive_upload()
n<-googledrive::drive_upload()
googledrive::drive_has_token()
googledrive::drive_auth()
googledrive::drive_has_token()
googledrive::drive_user()
n<-googledrive::drive_user()
n
user.email<-as.character(gargle::gargle_oauth_sitrep()$email)
gargle::gargle_oauth_sitrep()
d<-gargle::gargle_oauth_sitrep()
gargle::gargle_oauth_sitrep()
g<-gargle::gargle_oauth_sitrep()
g
length(g)
nrow(g)
nrow(g)<1
nrow(gargle::gargle_oauth_sitrep())<1
#skip_if_no_auth Skips test_that test if no authorisation token available for Google Drive
skip_if_no_auth <- function() {
if ((nrow(gargle::gargle_oauth_sitrep())<1)==T) {
skip("No authentication available")
}
}
gargle::gargle_oauth_sitrep()
(nrow(gargle::gargle_oauth_sitrep())
)
nrow(gargle::gargle_oauth_sitrep())<1
#skip_if_no_auth Skips test_that test if no authorisation token available for Google Drive
skip_if_no_auth <- function() {
if ((nrow(gargle::gargle_oauth_sitrep())<1)==T) {
skip("No authentication available")
}
}
#skip_if_no_GEE_credentials Skips test_that test if no Google Earth Engine credentials set-up
skip_if_no_GEE_credentials <- function() {
if ((rgee::ee_check_credentials())==F){
skip("No Google Earth Engine credentials available")
}
}
skip_if_no_auth()
#skip_if_no_auth Skips test_that test if no authorisation token available for Google Drive
skip_if_no_auth <- function() {
if ((nrow(gargle::gargle_oauth_sitrep())<1)==T) {
skip("No authentication available")
}
if ((nrow(gargle::gargle_oauth_sitrep())<1)==F) {
skip("Authentication available")
}
}
skip_if_no_auth()
if ((nrow(gargle::gargle_oauth_sitrep())<1)==T) {
skip("No authentication available")
}}
#skip_if_no_auth Skips test_that test if no authorisation token available for Google Drive
skip_if_no_auth <- function() {
if ((nrow(gargle::gargle_oauth_sitrep())<1)==T) {
skip("No authentication available")}}
#skip_if_no_GEE_credentials Skips test_that test if no Google Earth Engine credentials set-up
skip_if_no_GEE_credentials <- function() {
if ((rgee::ee_check_credentials())==F){
skip("No Google Earth Engine credentials available")
}
}
skip_if_no_GEE_credentials()
sink("cmdcheck.txt")
devtools::check()
devtools::check()
test_that("Success if temporal method random and spatial buffer", {
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
expect_equal(class(results),"data.frame")})
library(testthat)
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
devtools::load_all()
test_that("Success if temporal method random and spatial random, n.pseudoabs default", {
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
expect_equal(class(results),"data.frame")})
data("sample_occ_data")
occ.data=sample_occ_data
n.pseudoabs=10
temporal.method="random"
spatial.method="buffer"
spatial.buffer = c(100,1000),
spatial.buffer = c(100,1000)
temporal.ext=c("2005-01-01","2020-01-01")
first.buff<-rangemap::geobuffer_points(occ.data[, c("x","y")],radius=spatial.buffer[1],by_point = T)
first.buff<-rangemap::geobuffer_points(occ.data[, c("x","y")],radius=spatial.buffer[1],by_point = T,wrap_antimeridian=T)
data("occ_p", package = "rangemap")
coords <- occ_p[, 2:3]
# buffers
bufferp <- geobuffer_points(data = coords, radius = 25000)
# buffers
bufferp <- rangemap::geobuffer_points(data = coords, radius = 25000)
test_that("Success if temporal method random and spatial random, n.pseudoabs default", {
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
expect_equal(class(results),"data.frame")})
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
test_that("Success if temporal method random and spatial random, n.pseudoabs default", {
expect_warning(results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01")))
expect_equal(class(results),"data.frame")})
expect_warning(results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01")))
data("sample_occ_data",package="dynamicSDM")
data("sample_model_data")
