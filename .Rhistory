## Buffered generation of pseudo-absence co-ordinates
if(spatial.method=="buffer"){
### Check that if spatial buffer chosen, a temporal buffer of appropriate class, length and order is provided
if(missing(spatial.buffer)){stop("No spatial.buffer specified to generate pseudo-absence co-ordinates within.")}
if(!class(spatial.buffer)=="numeric"){stop("spatial.buffer must be numeric")}
if(!length(spatial.buffer)==2){stop("spatial.buffer must be length  2 representing the buffer in metres to generate coords in. e.g. c(500,3000) buffer of 500m to 3000m")}
if(spatial.buffer[1]-spatial.buffer[2]>0){stop("Second spatial.buffer must be further away than first")}
## Calculate the number of pseudo-absences to generate in buffer from each occurrence record to meet or slightly exceed the required amount
value<-ceiling(n.pseudoabs/nrow(occ.data))
# Create buffer shapefiles for given buffer min and max size from each occurrence record co-ordinates as specified by the user
spatial.buffer<-c(100000,1000000)
first.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[1],step_dg = 60,output = "sp")
coords <- occ.data[, c("x","y")]
first.buff3<-rangemap::geobuffer_points(coords,radius=100000,by_point = T)
second.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[2],step_dg = 60,output = "sp")
raster::crs(second.buff)<-NA
raster::crs(first.buff)<-NA
pseudoabs_coords=NULL ## Create vector for binding pseudoabsence co-ordinates too
for (x in 1:nrow(occ.data)){pseudoabs_coords<-rbind(pseudoabs_coords,sp::coordinates(sp::spsample(rgeos::gDifference(second.buff[x], first.buff[x]),type='random', n=value,iter=30)))}
colnames(pseudoabs_coords)<-c("x","y")}# Set pseudoabsence co-ordinate column names as "x" for co-ordinate longitude and "y" for co-ordinate latitude
## Buffered generation of pseudo-absence dates
if(temporal.method=="buffer"){
### Check that if temporal buffer chosen, a temporal buffer of appropriate class, length and order is provided
if (missing(temporal.buffer)){stop("No temporal.buffer specified specified to generate pseudo-absence dates within.")}
if(!class(temporal.buffer)=="numeric"){stop("temporal.buffer must be numeric")}
if(!length(temporal.buffer)==2){stop("temporal.buffer must be length(2) representing the buffer to generate coords in")}
if(temporal.buffer[1]-temporal.buffer[2]>0){stop("Second temporal.buffer must be higher than first")}
## Calculate the number of pseudo-absences to generate in buffer from each occurrence record to meet or slightly exceed the required amount
value<-ceiling(n.pseudoabs/nrow(occ.data))
## Generate list of max temporal buffer distance (specified by user) away from each occurrence record date
date1<-as.Date(with(occ.data, paste(year, month, day,sep="-")), "%Y-%m-%d")+ temporal.buffer[2]
pseudoabs_dates=date1[1] ## Create "Date" vector for binding pseudoabsence dates too
for (x in 1:length(date1)){pseudoabs_dates<-c(pseudoabs_dates,as.Date(date1[x]- sample(c(0:temporal.buffer[1],0:(-temporal.buffer[1])), value,replace=T)))} # For each occ.data record date, randomly select the calculated number of dates (object "value") within the buffer period
pseudoabs_dates<-pseudoabs_dates[2:length(pseudoabs_dates)] ## Remove first one as used to set vector class as "Date"
pseudoabs_dates<-as.data.frame(pseudoabs_dates)
pseudoabs_dates<-tidyr::separate(pseudoabs_dates, "pseudoabs_dates", c("year", "month", "day"), sep = "-")  }
# If either method "buffer" is chosen, there may be slightly more generated than specified by n.pseudoabs, so randomly select this amount from generated lists
if(temporal.method=="buffer" && spatial.method=="buffer"){
pseudo.df<-dplyr::sample_n(as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates)),n.pseudoabs)} ## Keeps co-ordinates and dates relevant to same occurrence record together before randomly selecting
if(temporal.method=="buffer" && spatial.method=="random"){
pseudoabs_dates<-dplyr::sample_n(as.data.frame(pseudoabs_dates),n.pseudoabs) ## As ceiling used to calculate maximum number of points in buffer to generate to meet specified number of pseudo.abs, this may be slightly too many. This randomyl selects the exact number specified by the user
pseudo.df<-as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates))}
if(temporal.method=="random" && spatial.method=="buffer"){
pseudoabs_coords<-dplyr::sample_n(as.data.frame(pseudoabs_coords),n.pseudoabs)
pseudo.df<-as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates))}
if(temporal.method=="random" && spatial.method=="random"){
pseudo.df<-as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates))}
return(pseudo.df)}
test_that("Success if spatial extent numeric", {
numeric<-c(20,36,-35,-12)
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="buffer",spatial.method="random",spatial.ext=numeric,temporal.buffer=c(14,30))
expect_equal(class(results),"data.frame")})
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="buffer",spatial.method="random",spatial.ext=numeric,temporal.buffer=c(14,30))
results
test_that("Success if spatial extent extent", {
Extent<-raster::extent(c(20,36,-35,-12))
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="buffer",spatial.method="random",spatial.ext=Extent,temporal.buffer=c(14,30))
expect_equal(class(results),"data.frame")})
test_that("Success if spatial extent raster", {
raster<-raster::raster(raster::extent(c(20,36,-35,-12)))
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="buffer",spatial.method="random",spatial.ext=raster,temporal.buffer=c(14,30))
expect_equal(class(results),"data.frame")})
test_that("Success if spatial extent polygon", {
polygon<-sp::Polygon(cbind(c(20,12,36,36),c(-35,-12,-35,-12)))
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="buffer",spatial.method="random",spatial.ext=polygon,temporal.buffer=c(14,30))
expect_equal(class(results),"data.frame")})
test_that("Success if temporal method random and spatial buffer", {
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
expect_equal(class(results),"data.frame")})
test_that("Success if temporal method random and spatial random, n.pseudoabs default", {
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
expect_equal(class(results),"data.frame")})
devtools::load_all()
devtools::load_all()
devtools::document()
install.packages("renv")
renv::dependencies(path="C:/Users/eerdo/Documents/GitHub/dynamicSDM/R")
r<-renv::dependencies(path="C:/Users/eerdo/Documents/GitHub/dynamicSDM/R")
r
unique(r)
r$Package
unique(r$Package)
sort(unique(r$Package))
rgee::ee_check_credentials()
rgee::ee_users()
d<-rgee::ee_check_credentials()
(rgee::ee_check_credentials())==F
user.email<-as.character(gargle::gargle_oauth_sitrep()$email)
gargle::gargle_oauth_sitrep()
b<-gargle::gargle_oauth_sitrep()
View(b)
googledrive::drive_upload()
n<-googledrive::drive_upload()
googledrive::drive_has_token()
googledrive::drive_auth()
googledrive::drive_has_token()
googledrive::drive_user()
n<-googledrive::drive_user()
n
user.email<-as.character(gargle::gargle_oauth_sitrep()$email)
gargle::gargle_oauth_sitrep()
d<-gargle::gargle_oauth_sitrep()
gargle::gargle_oauth_sitrep()
g<-gargle::gargle_oauth_sitrep()
g
length(g)
nrow(g)
nrow(g)<1
nrow(gargle::gargle_oauth_sitrep())<1
#skip_if_no_auth Skips test_that test if no authorisation token available for Google Drive
skip_if_no_auth <- function() {
if ((nrow(gargle::gargle_oauth_sitrep())<1)==T) {
skip("No authentication available")
}
}
gargle::gargle_oauth_sitrep()
(nrow(gargle::gargle_oauth_sitrep())
)
nrow(gargle::gargle_oauth_sitrep())<1
#skip_if_no_auth Skips test_that test if no authorisation token available for Google Drive
skip_if_no_auth <- function() {
if ((nrow(gargle::gargle_oauth_sitrep())<1)==T) {
skip("No authentication available")
}
}
#skip_if_no_GEE_credentials Skips test_that test if no Google Earth Engine credentials set-up
skip_if_no_GEE_credentials <- function() {
if ((rgee::ee_check_credentials())==F){
skip("No Google Earth Engine credentials available")
}
}
skip_if_no_auth()
#skip_if_no_auth Skips test_that test if no authorisation token available for Google Drive
skip_if_no_auth <- function() {
if ((nrow(gargle::gargle_oauth_sitrep())<1)==T) {
skip("No authentication available")
}
if ((nrow(gargle::gargle_oauth_sitrep())<1)==F) {
skip("Authentication available")
}
}
skip_if_no_auth()
if ((nrow(gargle::gargle_oauth_sitrep())<1)==T) {
skip("No authentication available")
}}
#skip_if_no_auth Skips test_that test if no authorisation token available for Google Drive
skip_if_no_auth <- function() {
if ((nrow(gargle::gargle_oauth_sitrep())<1)==T) {
skip("No authentication available")}}
#skip_if_no_GEE_credentials Skips test_that test if no Google Earth Engine credentials set-up
skip_if_no_GEE_credentials <- function() {
if ((rgee::ee_check_credentials())==F){
skip("No Google Earth Engine credentials available")
}
}
skip_if_no_GEE_credentials()
sink("cmdcheck.txt")
devtools::check()
devtools::check()
test_that("Success if temporal method random and spatial buffer", {
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
expect_equal(class(results),"data.frame")})
library(testthat)
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
devtools::load_all()
test_that("Success if temporal method random and spatial random, n.pseudoabs default", {
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
expect_equal(class(results),"data.frame")})
data("sample_occ_data")
occ.data=sample_occ_data
n.pseudoabs=10
temporal.method="random"
spatial.method="buffer"
spatial.buffer = c(100,1000),
spatial.buffer = c(100,1000)
temporal.ext=c("2005-01-01","2020-01-01")
first.buff<-rangemap::geobuffer_points(occ.data[, c("x","y")],radius=spatial.buffer[1],by_point = T)
first.buff<-rangemap::geobuffer_points(occ.data[, c("x","y")],radius=spatial.buffer[1],by_point = T,wrap_antimeridian=T)
data("occ_p", package = "rangemap")
coords <- occ_p[, 2:3]
# buffers
bufferp <- geobuffer_points(data = coords, radius = 25000)
# buffers
bufferp <- rangemap::geobuffer_points(data = coords, radius = 25000)
test_that("Success if temporal method random and spatial random, n.pseudoabs default", {
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
expect_equal(class(results),"data.frame")})
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
test_that("Success if temporal method random and spatial random, n.pseudoabs default", {
expect_warning(results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01")))
expect_equal(class(results),"data.frame")})
expect_warning(results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01")))
data("sample_occ_data",package="dynamicSDM")
data("sample_model_data")
#skip_if_no_GEE_credentials Skips test_that test if no Google Earth Engine credentials set-up
skip_if_no_GEE_credentials <- function() {
##Import python module
ee <- reticulate::import("ee")
if ((rgee::ee_check_credentials())==F){
skip("No Google Earth Engine credentials available")
}
}
test_that("Works if spatial.ext = polygon and Google Drive used", {
skip_if_no_GEE_credentials()
user.email<-as.character(gargle::gargle_oauth_sitrep()$email)
dates=c("2010-01-01","2010-04-01")
polygon<-sp::Polygon(cbind(c(12,12,36,36),c(-35,-12,-35,-12)))
results<-dynamic_proj_covariates(dates=dates,varnames=c("Temperaturemean","TemperatureEightmean","Precipitationsum","Precipitation8Wsum"),user.email=user.email,drive.folder="temporary_folder_buffered_extraction",
spatial.ext=polygon,spatial.res.degrees=0.05,resample.method="bilinear",
save.drive.folder = "testfiles")
expect_equal(length(results),length(dates))})
dates<-c("2010-01-01","2011-01-01")
Extent<-raster::extent(c(12,36,-35,-12))
#skip_if_no_GEE_credentials Skips test_that test if no Google Earth Engine credentials set-up
skip_if_no_GEE_credentials <- function() {
##Import python module
ee <- reticulate::import("ee")
if ((rgee::ee_check_credentials())==F){
skip("No Google Earth Engine credentials available")
}
}
library(testthat)
test_that("Works if spatial.ext = polygon and Google Drive used", {
skip_if_no_GEE_credentials()
user.email<-as.character(gargle::gargle_oauth_sitrep()$email)
dates=c("2010-01-01","2010-04-01")
polygon<-sp::Polygon(cbind(c(12,12,36,36),c(-35,-12,-35,-12)))
results<-dynamic_proj_covariates(dates=dates,varnames=c("Temperaturemean","TemperatureEightmean","Precipitationsum","Precipitation8Wsum"),user.email=user.email,drive.folder="temporary_folder_buffered_extraction",
spatial.ext=polygon,spatial.res.degrees=0.05,resample.method="bilinear",
save.drive.folder = "testfiles")
expect_equal(length(results),length(dates))})
data("sample_model_data",package ="dynamicSDM")
data("sample_model_data"
)
split = sample(c(TRUE, FALSE), nrow(sample_model_data), replace=TRUE, prob=c(0.75, 0.25))
training = sample_model_data[split, ]
testing = sample_model_data[!split, ]
brt_fit(occ.data=training,
brt_fit(occ.data=training,
test.data=testing,
response.col = "presence.absence",
distribution="bernoulli",
weights.col="sampling_weights",
varnames=colnames(training)[9:12])
brt_fit(occ.data=training,
test.data=testing,
response.col = "presence.absence",
distribution="bernoulli",
weights.col="sampling_weights",
varnames=colnames(training)[9:12])
brt_fit(occ.data=training,
test.data=testing,
response.col = "presence.absence",
distribution="bernoulli",
weights.col="sampling_weights",
varnames=colnames(training)[9:12])
devtools::load_all()
brt_fit(occ.data=training,
brt_fit(occ.data=training,
brt_fit(occ.data=training,
test.data=testing,
response.col = "presence.absence",
distribution="bernoulli"
,
weights.col="sampling_weights",
varnames=colnames(training)[9:12])
devtools::load_all()
devtools::load_all()
devtools::build()
devtools::document()
dynamic_proj_dates(startdate="2000-01-01",enddate="2001-01-01",interval.level = "month",interval=2)
devtools::load_all()
devtools::document()
add_github_actions_check_badge()
install.packages("rcompendium")
rcompendium::add_github_actions_check_badge
rcompendium::add_github_actions_check_badge()
rcompendium::add_github_actions_check()
add_github_actions_check_badge()
rcompendium::add_github_actions_check_badge()
rcompendium::add_github_actions_check()
rcompendium::add_github_actions_check("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")
rcompendium::add_github_actions_check("")
rcompendium::add_github_actions_check_badge()
gert::git_config_global()
devtools::check()
c(rep(1,3),rep(2,3))
data("sample_model_data")
sample_model_data_test<-dplyr::sample_n(sample_model_data,100)
sample_model_data_train<-dplyr::sample_n(sample_model_data,1000)
occ.data = sample_model_data_train
response.col = "presence.absence"
expect_error(brt_fit(occ.data = sample_model_data_train,test.data=sample_model_data_test,response.col = "presence.absence",
arnames=colnames(sample_model_data_train)[9:12]
varnames=colnames(sample_model_data_train)[9:12]
# Remove rows that contain NA in response variable or explanatory variable columns and spatiotemporal blocking/weights column if applicable.
occ.data<-occ.data[,!is.na(occ.data[,response.col])]
occ.data
occ.data[,response.col]
is.na(occ.data[,response.col])
# Remove rows that contain NA in response variable or explanatory variable columns and spatiotemporal blocking/weights column if applicable.
occ.data<-occ.data![,is.na(occ.data[,response.col])]
# Remove rows that contain NA in response variable or explanatory variable columns and spatiotemporal blocking/weights column if applicable.
occ.data<-occ.data-c[,is.na(occ.data[,response.col])]
# Remove rows that contain NA in response variable or explanatory variable columns and spatiotemporal blocking/weights column if applicable.
occ.data<-occ.data[,-c(is.na(occ.data[,response.col]))]
is.na(occ.data[,response.col])
occ.data = sample_model_data_train
occ.data[,response.col]
is.na(occ.data[,response.col])
occ.data[,-c(is.na(occ.data[,response.col]))]
occ.data = sample_model_data_train
# Remove rows that contain NA in response variable or explanatory variable columns and spatiotemporal blocking/weights column if applicable.
occ.data<-occ.data[-c(is.na(occ.data[,response.col])),]
occ.data = sample_model_data_train
# Remove rows that contain NA in response variable or explanatory variable columns and spatiotemporal blocking/weights column if applicable.
occ.data<-occ.data[-c(!is.na(occ.data[,response.col])),]
occ.data
response.col
occ.data<-occ.data[-c(!is.na(occ.data[,varnames])),]
varnames=colnames(sample_model_data_train)[9:12]
occ.data<-occ.data[-c(!is.na(occ.data[,varnames])),]
occ.data<-occ.data[-c(!is.na(occ.data[,varnames])),]
occ.data[,response.col]
# Remove rows that contain NA in response variable or explanatory variable columns and spatiotemporal blocking/weights column if applicable.
occ.data[!is.na(occ.data[,block.col]),]
# Remove rows that contain NA in response variable or explanatory variable columns and spatiotemporal blocking/weights column if applicable.
occ.data[!is.na(occ.data[,response.col]),]
# Remove rows that contain NA in response variable or explanatory variable columns and spatiotemporal blocking/weights column if applicable.
occ.data<-occ.data[!is.na(occ.data[,response.col]),]
occ.data<-occ.data[!is.na(occ.data[,varnames]),]
occ.data
occ.data<-occ.data[!is.na(occ.data[,varnames]),]
occ.data[,varnames])
occ.data[,varnames]
is.na(occ.data[,varnames])
devtools::load_all()
devtools::load_all()
devtools::document()
devtools::build_manual()
devtools::
devtools::check()
test_path("testdata")
test_that::test_path("testdata")
testthat::test_path("testdata")
paste(testthat::test_path("testdata"))
testthat::test_path("test-files")
list(testthat::test_path("test-files"))
list.files(testthat::test_path("test-files"))
test_that("works with spatial.ext as numeric", {
numeric<-c(12,36,-35,-12)
results<-get_moving_window(radial.distance=100,spatial.res.degrees=0.5,spatial.ext=numeric)
expect_equal(class(results),"matrix")})
library(testthat
library(testthat)
library(testthat)
test_that("works with spatial.ext as numeric", {
numeric<-c(12,36,-35,-12)
results<-get_moving_window(radial.distance=100,spatial.res.degrees=0.5,spatial.ext=numeric)
expect_equal(class(results),"matrix")})
devtools::load_all()
results<-get_moving_window(radial.distance=100,spatial.res.degrees=0.5,spatial.ext=numeric)
numeric<-c(12,36,-35,-12)
results<-get_moving_window(radial.distance=100,spatial.res.degrees=0.5,spatial.ext=numeric)
results
class(results)
Extent<-raster::extent(c(12,36,-35,-12))
results<-get_moving_window(radial.distance=100,spatial.res.degrees=0.5,spatial.ext=Extent)
class(results)
numeric<-c(12,36,-35,-12)
raster<-raster::raster(raster::extent(numeric))
results<-get_moving_window(radial.distance=100000,spatial.res.degrees=0.5,spatial.ext=raster)
class(results)
polygon<-sp::Polygon(cbind(c(12,12,36,36),c(-35,-12,-35,-12)))
results<-get_moving_window(radial.distance=100000,spatial.res.degrees=0.5,spatial.ext=polygon)
class(results)
test_that("stops if no spatial.res.degrees and no spatial.res.metres", {expect_error(get_moving_window(radial.distance=100, spatial.ext = c(11.72083,40.84583,-46.9625 ,-4.425 )))})
test_that("stops if no radial.distance", {expect_error(get_moving_window(spatial.res.degrees=0.3,spatial.res.metres = 1000, spatial.ext = c(11.72083,40.84583,-46.9625 ,-4.425 )))})
test_that("stops if spatial.res.degrees class is not numeric", {expect_error(get_moving_window(radial.distance=100,spatial.res.degrees="zero point five degrees",spatial.res.metres = 1000, spatial.ext = c(11.72083,40.84583,-46.9625 ,-4.425 )))})
test_that("stops if spatial.res.degrees given but spatial.ext not given", {expect_error(get_moving_window(radial.distance=100,spatial.res.degrees=0.5))})
test_that("stops if spatial.res.degrees and spatial.ext class invalid", {expect_error(get_moving_window(radial.distance=100,spatial.res.degrees=0.5,spatial.ext="southernafrica"))})
test_that("stops if spatial.res.degrees and spatial.ext class numeric and incorrect length invalid", {
expect_error(get_moving_window(radial.distance=100,spatial.res.degrees=0.5,spatial.ext=c(2,3,4)))})
test_that("stops if spatial.res.degrees and spatial.ext class numeric and incorrect length invalid", {
expect_error(get_moving_window(radial.distance=100,spatial.res.degrees=0.5,spatial.ext=c(2,3,4)))})
test_that("works with spatial.ext as numeric", {
numeric<-c(12,36,-35,-12)
results<-get_moving_window(radial.distance=100,spatial.res.degrees=0.5,spatial.ext=numeric)
expect_equal(class(results),"matrix")})
test_that("works with spatial.ext as Extent", {
Extent<-raster::extent(c(12,36,-35,-12))
results<-get_moving_window(radial.distance=100,spatial.res.degrees=0.5,spatial.ext=Extent)
expect_equal(class(results),"matrix")})
test_that("works with spatial.ext as raster", {
numeric<-c(12,36,-35,-12)
raster<-raster::raster(raster::extent(numeric))
results<-get_moving_window(radial.distance=100000,spatial.res.degrees=0.5,spatial.ext=raster)
expect_equal(class(results),"matrix")})
test_that("works with spatial.ext as polygon", {
polygon<-sp::Polygon(cbind(c(12,12,36,36),c(-35,-12,-35,-12)))
results<-get_moving_window(radial.distance=100000,spatial.res.degrees=0.5,spatial.ext=polygon)
expect_equal(class(results),"matrix")})
test_that("stops if spatial.res.degrees and spatial.ext class invalid", {
expect_error(get_moving_window(radial.distance=100000,spatial.res.degrees=0.5,spatial.ext="southernafrica"))})
test_that("Error if wrong class spatial.res.metres", {
expect_error(get_moving_window(radial.distance=100000,spatial.res.metres="300m"))})
class(results)
matrix((1/cells*cells),nrow=cells,ncol=cells)
cells<-3
matrix((1/cells*cells),nrow=cells,ncol=cells)
a<-matrix((1/cells*cells),nrow=cells,ncol=cells)
a
class(results)[1]
test_that("stops if no spatial.res.degrees and no spatial.res.metres", {expect_error(get_moving_window(radial.distance=100, spatial.ext = c(11.72083,40.84583,-46.9625 ,-4.425 )))})
test_that("stops if no radial.distance", {expect_error(get_moving_window(spatial.res.degrees=0.3,spatial.res.metres = 1000, spatial.ext = c(11.72083,40.84583,-46.9625 ,-4.425 )))})
test_that("stops if spatial.res.degrees class is not numeric", {expect_error(get_moving_window(radial.distance=100,spatial.res.degrees="zero point five degrees",spatial.res.metres = 1000, spatial.ext = c(11.72083,40.84583,-46.9625 ,-4.425 )))})
test_that("stops if spatial.res.degrees given but spatial.ext not given", {expect_error(get_moving_window(radial.distance=100,spatial.res.degrees=0.5))})
test_that("stops if spatial.res.degrees and spatial.ext class invalid", {expect_error(get_moving_window(radial.distance=100,spatial.res.degrees=0.5,spatial.ext="southernafrica"))})
test_that("stops if spatial.res.degrees and spatial.ext class numeric and incorrect length invalid", {
expect_error(get_moving_window(radial.distance=100,spatial.res.degrees=0.5,spatial.ext=c(2,3,4)))})
test_that("stops if spatial.res.degrees and spatial.ext class numeric and incorrect length invalid", {
expect_error(get_moving_window(radial.distance=100,spatial.res.degrees=0.5,spatial.ext=c(2,3,4)))})
test_that("works with spatial.ext as numeric", {
numeric<-c(12,36,-35,-12)
results<-get_moving_window(radial.distance=100,spatial.res.degrees=0.5,spatial.ext=numeric)
expect_equal(class(results)[1],"matrix")})
test_that("works with spatial.ext as Extent", {
Extent<-raster::extent(c(12,36,-35,-12))
results<-get_moving_window(radial.distance=100,spatial.res.degrees=0.5,spatial.ext=Extent)
expect_equal(class(results)[1],"matrix")})
test_that("works with spatial.ext as raster", {
numeric<-c(12,36,-35,-12)
raster<-raster::raster(raster::extent(numeric))
results<-get_moving_window(radial.distance=100000,spatial.res.degrees=0.5,spatial.ext=raster)
expect_equal(class(results)[1],"matrix")})
test_that("works with spatial.ext as polygon", {
polygon<-sp::Polygon(cbind(c(12,12,36,36),c(-35,-12,-35,-12)))
results<-get_moving_window(radial.distance=100000,spatial.res.degrees=0.5,spatial.ext=polygon)
expect_equal(class(results)[1],"matrix")})
test_that("stops if spatial.res.degrees and spatial.ext class invalid", {
expect_error(get_moving_window(radial.distance=100000,spatial.res.degrees=0.5,spatial.ext="southernafrica"))})
test_that("Error if wrong class spatial.res.metres", {
expect_error(get_moving_window(radial.distance=100000,spatial.res.metres="300m"))})
test_that("stops if no occ.data provided", {
expect_error(spatiotemp_block(spatial.layer=biome_layer,spatial.split.degrees=3,temporal.block=c("month"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=10))})
test_that("stops if no vars.to.block.by provided", {
expect_error(spatiotemp_block(occ.data = sample_model_data,spatial.layer=biome_layer,spatial.split.degrees=3,temporal.block=c("month"),n.blocks=10))})
test_that("stops if spatial.layer not class RasterLayer", {
expect_error(spatiotemp_block(occ.data = sample_model_data,spatial.layer=c(0,20,-20,30),spatial.split.degrees=3,temporal.block=c("month"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=10))})
test_that("stops if spatial.split.degrees not class numeric", {
expect_error(spatiotemp_block(occ.data = sample_model_data,spatial.layer=biome_layer,spatial.split.degrees="three",temporal.block=c("month"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=10))})
test_that("stops if spatial.layer given but no spatial.split.degrees", {
expect_error(spatiotemp_block(occ.data = sample_model_data,spatial.layer=biome_layer,temporal.block=c("month"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=10))})
test_that("stops if temporal.block not accepted", {
expect_error(spatiotemp_block(occ.data = sample_model_data,spatial.layer=biome_layer,spatial.split.degrees=3,temporal.block=c("decadal"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=10))})
test_that("Only temporal blocking by one level, results in correct number of unique blocking categories", {
n<-as.numeric(sample(1:10,1))
df<-spatiotemp_block(occ.data = sample_model_data,temporal.block=c("month"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=n)
expect_equal(length(unique(df$BLOCK.CATS)),n)})
test_that("Doesn't error with only temporal blocking by two feature", {
n<-as.numeric(sample(1:10,1))
df<-spatiotemp_block(occ.data = sample_model_data,temporal.block=c("quarter","year"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=n)
expect_equal(length(unique(df$BLOCK.CATS)),n)})
test_that("Only spatial blocking, results in correct number of unique blocking categories", {
n<-as.numeric(sample(1:10,1))
df<-spatiotemp_block(occ.data = sample_model_data,spatial.layer = biome_layer,spatial.split.degrees=3,vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=n)
expect_equal(length(unique(df$BLOCK.CATS)),n)})
data("sample_model_data")
sample_model_data<-dplyr::sample_n(sample_model_data,8000)
data("biome_layer")
test_that("Doesn't error with only temporal blocking by two feature", {
n<-as.numeric(sample(1:10,1))
df<-spatiotemp_block(occ.data = sample_model_data,temporal.block=c("quarter","year"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=n)
expect_equal(length(unique(df$BLOCK.CATS)),n)})
occ.data = sample_model_data
spatial.layer = biome_layer
spatial.split.degrees=3
vars.to.block.by=colnames(sample_model_data)[9:12]
n<-as.numeric(sample(1:10,1))
n.blocks=n
test_that("Only spatial blocking, results in correct number of unique blocking categories", {
n<-as.numeric(sample(2:10,1))
df<-spatiotemp_block(occ.data = sample_model_data,spatial.layer = biome_layer,spatial.split.degrees=3,vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=n)
expect_equal(length(unique(df$BLOCK.CATS)),n)})
test_that("Doesn't error with only temporal blocking by two feature", {
n<-as.numeric(sample(2:10,1))
df<-spatiotemp_block(occ.data = sample_model_data,temporal.block=c("quarter","year"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=n)
expect_equal(length(unique(df$BLOCK.CATS)),n)})
test_that("Only spatial blocking, results in correct number of unique blocking categories", {
n<-as.numeric(sample(2:10,1))
df<-spatiotemp_block(occ.data = sample_model_data,spatial.layer = biome_layer,spatial.split.degrees=3,vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=n)
expect_equal(length(unique(df$BLOCK.CATS)),n)})
test_that("Both spatial and temporal blocking, results in correct number of unique blocking categories", {
n<-as.numeric(sample(2:10,1))
df<-spatiotemp_block(occ.data = sample_model_data,spatial.layer = biome_layer,spatial.split.degrees=3,temporal.block=c("month"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=n)
expect_equal(length(unique(df$BLOCK.CATS)),n)})
test_that("Errors if too many blocks expected", {
expect_error(spatiotemp_block(occ.data = sample_model_data,spatial.layer = biome_layer,spatial.split.degrees=3,temporal.block=c("month"),vars.to.block.by=colnames(sample_model_data)[9:12],n.blocks=100000))})
terra::crs("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
proj4string = terra::crs("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
is(proj4string, "CRS")
proj4string = raster::crs("+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0")
proj4string
eticulate::import("ee")
t <- try(reticulate::import("ee"))
t
#skip_if_no_GEE_credentials Skips test_that test if no Google Earth Engine credentials set-up
skip_if_no_GEE_credentials <- function() {
tryCatch(reticulate::import("ee"),  error = function(e)  skip("No Google Earth Engine credentials available")) # => 1
}
devtools::load_all()
devtools::document()
