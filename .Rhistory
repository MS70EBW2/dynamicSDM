temporal.method="buffer"
spatial.method="random"
spatial.ext=numeric
temporal.buffer=c(14,30)
# Match argument to available options
temporal.method<-match.arg(arg = temporal.method, choices = c( "buffer","random"))
spatial.method<-match.arg(arg = spatial.method, choices = c( "buffer","random"))
### Numeric vector to polygon
if(class(spatial.ext)=="numeric" && length(spatial.ext)==4){spatial.ext<-as(raster::extent(spatial.ext[1],spatial.ext[2],spatial.ext[3],spatial.ext[4]), 'SpatialPolygons')}
### Extent object to polygon
if(class(spatial.ext)=="Extent"){spatial.ext<-as(spatial.ext, 'SpatialPolygons')}
### RasterLayer object to polygon
if(class(spatial.ext)=="RasterLayer"){spatial.ext<-as(raster::extent(spatial.ext), 'SpatialPolygons')}
pseudoabs_coords<-as.data.frame(sp::spsample(spatial.ext ,type='random', n=n.pseudoabs,iter=30))} ## Randomly generate specified number of pseudo-absence co-ordinates within extent polygon
pseudoabs_coords<-as.data.frame(sp::spsample(spatial.ext ,type='random', n=n.pseudoabs,iter=30))
## Calculate the number of pseudo-absences to generate in buffer from each occurrence record to meet or slightly exceed the required amount
value<-ceiling(n.pseudoabs/nrow(occ.data))
first.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[1],step_dg = 60,output = "sp")
second.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[2],step_dg = 60,output = "sp")
spatial.method="buffer"
spatial.buffer=c(100,1000)
## Calculate the number of pseudo-absences to generate in buffer from each occurrence record to meet or slightly exceed the required amount
value<-ceiling(n.pseudoabs/nrow(occ.data))
first.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[1],step_dg = 60,output = "sp")
install.packages(spatialEco)
install.packages("spatialEco")
geobuffer_pts
geobuffer::geobuffer_pts
spob<-sp::SpatialPoints(data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])))
rgeos::gBuffer(spob, byid=FALSE, id=NULL, width=1.0, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0)
first.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[1],step_dg = 60,output = "sp")
plot(first.buff)
spatial.buffer
second.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[2],step_dg = 60,output = "sp")
plot(second.buff)
# Create buffer shapefiles for given buffer min and max size from each occurrence record co-ordinates as specified by the user
spatial.buffer<-c(100000,1000000)
first.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[1],step_dg = 60,output = "sp")
plot(first.buff)
rgeos::gBuffer(spob, byid=FALSE, id=NULL, width=100000, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0)
plot(rgeos::gBuffer(spob, byid=FALSE, id=NULL, width=100000, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0))
rgeos::gBuffer(spob, byid=TRUE, id=TRUE, width=100000, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0)
rgeos::gBuffer(spob, byid=TRUE,  width=100000, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0)
first.buff
first.buff2<-rgeos::gBuffer(spob, byid=TRUE,  width=100000, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0)
plot(first.buff2)
plot(first.buff)
spob<-sp::SpatialPoints(data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])))
first.buff2<-rgeos::gBuffer(spob, byid=TRUE,  width=100000, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0)
plot(first.buff2)
spob<-sp::SpatialPoints(data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])))
first.buff2<-rgeos::gBuffer(spob, byid=TRUE,  width=100000, quadsegs=5, capStyle="ROUND",
joinStyle="ROUND", mitreLimit=1.0)
first.buff2
first.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[1],step_dg = 60,output = "sp")
first.buff
first.buff2<-rgeos::gBuffer(spob, byid=TRUE,  width=100000)
first.buff2
spob
spob<-sp::SpatialPoints(data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])))
spob <- sp::spTransform(spob, CRS("+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs"))
first.buff2<-rgeos::gBuffer(spob, byid=TRUE,  width=100000)
spob<-sp::SpatialPoints(data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])))
spob<-sp::SpatialPoints(data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])))
c(occ.data[,"x"])
sites <- data.frame(Lon = c(occ.data[,"x"]), Lat = c(occ.data[,"y"]))
coordinates(sites) <- ~Lon + Lat
proj4string(sites) <- CRS("+proj=longlat")
sites <- spTransform(sites, CRS = CRS("+init=epsg:3857"))
spTransform
first.buff2<-rgeos::gBuffer(spob, byid=TRUE,  width=100000)
first.buff2<-rgeos::gBuffer(sites, byid=TRUE,  width=100000)
plot(first.buff2)
plot(first.buff)
first.buff2
first.buff
first.buff
first.buff2
install.packages("rangemap")
first.buff3<-rangemap::geobuffer_points(sites,radius=100000,by_point = T)
sites <- matrix(Lon = c(occ.data[,"x"]), Lat = c(occ.data[,"y"]))
sites <- matrix(occ.data[,"x"], occ.data[,"y"])
sites <- matrix(as.data.frame(occ.data[,"x"], occ.data[,"y"]))
sites <- as.matrix(as.data.frame(occ.data[,"x"], occ.data[,"y"]))
coords <- occ.data[, c("x","y"]
first.buff3<-rangemap::geobuffer_points(sites,radius=100000,by_point = T)
first.buff2<-rgeos::gBuffer(sites, byid=TRUE,  width=100000)
plot(first.buff)
rangemap::geobuffer_points()
second.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[2],step_dg = 60,output = "sp")
raster::crs(second.buff)<-NA
raster::crs(first.buff)<-NA
pseudoabs_coords=NULL ## Create vector for binding pseudoabsence co-ordinates too
for (x in 1:nrow(occ.data)){pseudoabs_coords<-rbind(pseudoabs_coords,sp::coordinates(sp::spsample(rgeos::gDifference(second.buff[x], first.buff[x]),type='random', n=value,iter=30)))}
colnames(pseudoabs_coords)<-c("x","y")}# Set pseudoabsence co-ordinate column names as "x" for co-ordinate longitude and "y" for co-ordinate latitude
## Buffered generation of pseudo-absence dates
if(temporal.method=="buffer"){
### Check that if temporal buffer chosen, a temporal buffer of appropriate class, length and order is provided
if (missing(temporal.buffer)){stop("No temporal.buffer specified specified to generate pseudo-absence dates within.")}
if(!class(temporal.buffer)=="numeric"){stop("temporal.buffer must be numeric")}
if(!length(temporal.buffer)==2){stop("temporal.buffer must be length(2) representing the buffer to generate coords in")}
if(temporal.buffer[1]-temporal.buffer[2]>0){stop("Second temporal.buffer must be higher than first")}
## Calculate the number of pseudo-absences to generate in buffer from each occurrence record to meet or slightly exceed the required amount
value<-ceiling(n.pseudoabs/nrow(occ.data))
## Generate list of max temporal buffer distance (specified by user) away from each occurrence record date
date1<-as.Date(with(occ.data, paste(year, month, day,sep="-")), "%Y-%m-%d")+ temporal.buffer[2]
pseudoabs_dates=date1[1] ## Create "Date" vector for binding pseudoabsence dates too
for (x in 1:length(date1)){pseudoabs_dates<-c(pseudoabs_dates,as.Date(date1[x]- sample(c(0:temporal.buffer[1],0:(-temporal.buffer[1])), value,replace=T)))} # For each occ.data record date, randomly select the calculated number of dates (object "value") within the buffer period
pseudoabs_dates<-pseudoabs_dates[2:length(pseudoabs_dates)] ## Remove first one as used to set vector class as "Date"
pseudoabs_dates<-as.data.frame(pseudoabs_dates)
pseudoabs_dates<-tidyr::separate(pseudoabs_dates, "pseudoabs_dates", c("year", "month", "day"), sep = "-")  }
# If either method "buffer" is chosen, there may be slightly more generated than specified by n.pseudoabs, so randomly select this amount from generated lists
if(temporal.method=="buffer" && spatial.method=="buffer"){
pseudo.df<-dplyr::sample_n(as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates)),n.pseudoabs)} ## Keeps co-ordinates and dates relevant to same occurrence record together before randomly selecting
if(temporal.method=="buffer" && spatial.method=="random"){
pseudoabs_dates<-dplyr::sample_n(as.data.frame(pseudoabs_dates),n.pseudoabs) ## As ceiling used to calculate maximum number of points in buffer to generate to meet specified number of pseudo.abs, this may be slightly too many. This randomyl selects the exact number specified by the user
pseudo.df<-as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates))}
if(temporal.method=="random" && spatial.method=="buffer"){
pseudoabs_coords<-dplyr::sample_n(as.data.frame(pseudoabs_coords),n.pseudoabs)
pseudo.df<-as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates))}
if(temporal.method=="random" && spatial.method=="random"){
pseudo.df<-as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates))}
return(pseudo.df)}
coords <- occ.data[, c("x","y")]
coords
first.buff3<-rangemap::geobuffer_points(coords,radius=100000,by_point = T)
coords <- occ.data[, c("x","y")]
first.buff3<-rangemap::geobuffer_points(coords,radius=100000,by_point = T)
plot(first.buff)
plot(first.buff3)
first.buff3
first.buff
spatiotemp_pseudoabs<-function(spatial.method,temporal.method,occ.data=NULL,spatial.ext=NULL,temporal.ext=NULL,spatial.buffer=NULL,temporal.buffer=NULL,n.pseudoabs=100){
if(!class(n.pseudoabs)=="numeric"){stop("n.pseudoabs should be a numeric value")}
# Match argument to available options
temporal.method<-match.arg(arg = temporal.method, choices = c( "buffer","random"))
spatial.method<-match.arg(arg = spatial.method, choices = c( "buffer","random"))
## Random generation of pseudo-absence co-ordinates
if(spatial.method=="random"){
### Check that if spatial random chosen, a spatial extent of appropriate class, length and order is provided
if (missing(spatial.ext)){stop("No spatial.ext specified to randomly generate pseudo-absence co-ordinates within.")}
if(!any(class(spatial.ext)==c("numeric","Extent","RasterLayer","Polygon"))){
stop("spatial.ext must be of class numeric, Extent, RasterLayer or Polygon")}
### Numeric vector to polygon
if(class(spatial.ext)=="numeric" && length(spatial.ext)==4){spatial.ext<-as(raster::extent(spatial.ext[1],spatial.ext[2],spatial.ext[3],spatial.ext[4]), 'SpatialPolygons')}
### Extent object to polygon
if(class(spatial.ext)=="Extent"){spatial.ext<-as(spatial.ext, 'SpatialPolygons')}
### RasterLayer object to polygon
if(class(spatial.ext)=="RasterLayer"){spatial.ext<-as(raster::extent(spatial.ext), 'SpatialPolygons')}
pseudoabs_coords<-as.data.frame(sp::spsample(spatial.ext ,type='random', n=n.pseudoabs,iter=30))} ## Randomly generate specified number of pseudo-absence co-ordinates within extent polygon
## Random generation of pseudo-absence dates
if(temporal.method=="random"){
### Check that if temporal random chosen, a temporal extent of appropriate class, length and order is provided
if (missing(temporal.ext)){stop("No temporal.ext specified to randomly generate pseudo-absence dates within.")}
if(!class(temporal.ext)=="character"){stop("temporal.ext must be character vector of length 2")}
if(!length(temporal.ext)==2){stop("two dates must be provides for temporal extent")}
tryCatch({dates<-as.Date(temporal.ext)},error=function(e){stop("Both dates invalid given in temporal.ext. Ensure format YYYY-MM-DD")})  ## Check dates are valid
if(any(is.na(dates))){stop("Invalid date given in temporal.ext. Ensure format YYYY-MM-DD")}
firstdate<-as.Date(temporal.ext)[1]
seconddate<-as.Date(temporal.ext)[2]
if(firstdate-seconddate>0){stop("First date must be before second date")} # Check dates are in order
pseudoabs_dates<- firstdate + sample(1:(seconddate-firstdate), size=n.pseudoabs,replace=T) ## Randomly generate dates within given extent
pseudoabs_dates<-tidyr::separate(as.data.frame(pseudoabs_dates), "pseudoabs_dates", c("year", "month", "day"), sep = "-")} ## Split dates into year, month and day columns for returned dataframe
## Buffered generation of pseudo-absence co-ordinates
if(spatial.method=="buffer"){
### Check that if spatial buffer chosen, a temporal buffer of appropriate class, length and order is provided
if(missing(spatial.buffer)){stop("No spatial.buffer specified to generate pseudo-absence co-ordinates within.")}
if(!class(spatial.buffer)=="numeric"){stop("spatial.buffer must be numeric")}
if(!length(spatial.buffer)==2){stop("spatial.buffer must be length  2 representing the buffer in metres to generate coords in. e.g. c(500,3000) buffer of 500m to 3000m")}
if(spatial.buffer[1]-spatial.buffer[2]>0){stop("Second spatial.buffer must be further away than first")}
## Calculate the number of pseudo-absences to generate in buffer from each occurrence record to meet or slightly exceed the required amount
value<-ceiling(n.pseudoabs/nrow(occ.data))
# Create buffer shapefiles for given buffer min and max size from each occurrence record co-ordinates as specified by the user
spatial.buffer<-c(100000,1000000)
first.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[1],step_dg = 60,output = "sp")
coords <- occ.data[, c("x","y")]
first.buff3<-rangemap::geobuffer_points(coords,radius=100000,by_point = T)
second.buff<-geobuffer::geobuffer_pts(xy = data.frame(lon = c(occ.data[,"x"]),lat = c(occ.data[,"y"])),dist_m = spatial.buffer[2],step_dg = 60,output = "sp")
raster::crs(second.buff)<-NA
raster::crs(first.buff)<-NA
pseudoabs_coords=NULL ## Create vector for binding pseudoabsence co-ordinates too
for (x in 1:nrow(occ.data)){pseudoabs_coords<-rbind(pseudoabs_coords,sp::coordinates(sp::spsample(rgeos::gDifference(second.buff[x], first.buff[x]),type='random', n=value,iter=30)))}
colnames(pseudoabs_coords)<-c("x","y")}# Set pseudoabsence co-ordinate column names as "x" for co-ordinate longitude and "y" for co-ordinate latitude
## Buffered generation of pseudo-absence dates
if(temporal.method=="buffer"){
### Check that if temporal buffer chosen, a temporal buffer of appropriate class, length and order is provided
if (missing(temporal.buffer)){stop("No temporal.buffer specified specified to generate pseudo-absence dates within.")}
if(!class(temporal.buffer)=="numeric"){stop("temporal.buffer must be numeric")}
if(!length(temporal.buffer)==2){stop("temporal.buffer must be length(2) representing the buffer to generate coords in")}
if(temporal.buffer[1]-temporal.buffer[2]>0){stop("Second temporal.buffer must be higher than first")}
## Calculate the number of pseudo-absences to generate in buffer from each occurrence record to meet or slightly exceed the required amount
value<-ceiling(n.pseudoabs/nrow(occ.data))
## Generate list of max temporal buffer distance (specified by user) away from each occurrence record date
date1<-as.Date(with(occ.data, paste(year, month, day,sep="-")), "%Y-%m-%d")+ temporal.buffer[2]
pseudoabs_dates=date1[1] ## Create "Date" vector for binding pseudoabsence dates too
for (x in 1:length(date1)){pseudoabs_dates<-c(pseudoabs_dates,as.Date(date1[x]- sample(c(0:temporal.buffer[1],0:(-temporal.buffer[1])), value,replace=T)))} # For each occ.data record date, randomly select the calculated number of dates (object "value") within the buffer period
pseudoabs_dates<-pseudoabs_dates[2:length(pseudoabs_dates)] ## Remove first one as used to set vector class as "Date"
pseudoabs_dates<-as.data.frame(pseudoabs_dates)
pseudoabs_dates<-tidyr::separate(pseudoabs_dates, "pseudoabs_dates", c("year", "month", "day"), sep = "-")  }
# If either method "buffer" is chosen, there may be slightly more generated than specified by n.pseudoabs, so randomly select this amount from generated lists
if(temporal.method=="buffer" && spatial.method=="buffer"){
pseudo.df<-dplyr::sample_n(as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates)),n.pseudoabs)} ## Keeps co-ordinates and dates relevant to same occurrence record together before randomly selecting
if(temporal.method=="buffer" && spatial.method=="random"){
pseudoabs_dates<-dplyr::sample_n(as.data.frame(pseudoabs_dates),n.pseudoabs) ## As ceiling used to calculate maximum number of points in buffer to generate to meet specified number of pseudo.abs, this may be slightly too many. This randomyl selects the exact number specified by the user
pseudo.df<-as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates))}
if(temporal.method=="random" && spatial.method=="buffer"){
pseudoabs_coords<-dplyr::sample_n(as.data.frame(pseudoabs_coords),n.pseudoabs)
pseudo.df<-as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates))}
if(temporal.method=="random" && spatial.method=="random"){
pseudo.df<-as.data.frame(cbind(pseudoabs_coords,pseudoabs_dates))}
return(pseudo.df)}
test_that("Success if spatial extent numeric", {
numeric<-c(20,36,-35,-12)
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="buffer",spatial.method="random",spatial.ext=numeric,temporal.buffer=c(14,30))
expect_equal(class(results),"data.frame")})
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="buffer",spatial.method="random",spatial.ext=numeric,temporal.buffer=c(14,30))
results
test_that("Success if spatial extent extent", {
Extent<-raster::extent(c(20,36,-35,-12))
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="buffer",spatial.method="random",spatial.ext=Extent,temporal.buffer=c(14,30))
expect_equal(class(results),"data.frame")})
test_that("Success if spatial extent raster", {
raster<-raster::raster(raster::extent(c(20,36,-35,-12)))
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="buffer",spatial.method="random",spatial.ext=raster,temporal.buffer=c(14,30))
expect_equal(class(results),"data.frame")})
test_that("Success if spatial extent polygon", {
polygon<-sp::Polygon(cbind(c(20,12,36,36),c(-35,-12,-35,-12)))
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="buffer",spatial.method="random",spatial.ext=polygon,temporal.buffer=c(14,30))
expect_equal(class(results),"data.frame")})
test_that("Success if temporal method random and spatial buffer", {
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
expect_equal(class(results),"data.frame")})
test_that("Success if temporal method random and spatial random, n.pseudoabs default", {
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
expect_equal(class(results),"data.frame")})
devtools::load_all()
devtools::load_all()
devtools::document()
install.packages("renv")
renv::dependencies(path="C:/Users/eerdo/Documents/GitHub/dynamicSDM/R")
r<-renv::dependencies(path="C:/Users/eerdo/Documents/GitHub/dynamicSDM/R")
r
unique(r)
r$Package
unique(r$Package)
sort(unique(r$Package))
rgee::ee_check_credentials()
rgee::ee_users()
d<-rgee::ee_check_credentials()
(rgee::ee_check_credentials())==F
user.email<-as.character(gargle::gargle_oauth_sitrep()$email)
gargle::gargle_oauth_sitrep()
b<-gargle::gargle_oauth_sitrep()
View(b)
googledrive::drive_upload()
n<-googledrive::drive_upload()
googledrive::drive_has_token()
googledrive::drive_auth()
googledrive::drive_has_token()
googledrive::drive_user()
n<-googledrive::drive_user()
n
user.email<-as.character(gargle::gargle_oauth_sitrep()$email)
gargle::gargle_oauth_sitrep()
d<-gargle::gargle_oauth_sitrep()
gargle::gargle_oauth_sitrep()
g<-gargle::gargle_oauth_sitrep()
g
length(g)
nrow(g)
nrow(g)<1
nrow(gargle::gargle_oauth_sitrep())<1
#skip_if_no_auth Skips test_that test if no authorisation token available for Google Drive
skip_if_no_auth <- function() {
if ((nrow(gargle::gargle_oauth_sitrep())<1)==T) {
skip("No authentication available")
}
}
gargle::gargle_oauth_sitrep()
(nrow(gargle::gargle_oauth_sitrep())
)
nrow(gargle::gargle_oauth_sitrep())<1
#skip_if_no_auth Skips test_that test if no authorisation token available for Google Drive
skip_if_no_auth <- function() {
if ((nrow(gargle::gargle_oauth_sitrep())<1)==T) {
skip("No authentication available")
}
}
#skip_if_no_GEE_credentials Skips test_that test if no Google Earth Engine credentials set-up
skip_if_no_GEE_credentials <- function() {
if ((rgee::ee_check_credentials())==F){
skip("No Google Earth Engine credentials available")
}
}
skip_if_no_auth()
#skip_if_no_auth Skips test_that test if no authorisation token available for Google Drive
skip_if_no_auth <- function() {
if ((nrow(gargle::gargle_oauth_sitrep())<1)==T) {
skip("No authentication available")
}
if ((nrow(gargle::gargle_oauth_sitrep())<1)==F) {
skip("Authentication available")
}
}
skip_if_no_auth()
if ((nrow(gargle::gargle_oauth_sitrep())<1)==T) {
skip("No authentication available")
}}
#skip_if_no_auth Skips test_that test if no authorisation token available for Google Drive
skip_if_no_auth <- function() {
if ((nrow(gargle::gargle_oauth_sitrep())<1)==T) {
skip("No authentication available")}}
#skip_if_no_GEE_credentials Skips test_that test if no Google Earth Engine credentials set-up
skip_if_no_GEE_credentials <- function() {
if ((rgee::ee_check_credentials())==F){
skip("No Google Earth Engine credentials available")
}
}
skip_if_no_GEE_credentials()
sink("cmdcheck.txt")
devtools::check()
devtools::check()
test_that("Success if temporal method random and spatial buffer", {
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
expect_equal(class(results),"data.frame")})
library(testthat)
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
devtools::load_all()
test_that("Success if temporal method random and spatial random, n.pseudoabs default", {
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
expect_equal(class(results),"data.frame")})
data("sample_occ_data")
occ.data=sample_occ_data
n.pseudoabs=10
temporal.method="random"
spatial.method="buffer"
spatial.buffer = c(100,1000),
spatial.buffer = c(100,1000)
temporal.ext=c("2005-01-01","2020-01-01")
first.buff<-rangemap::geobuffer_points(occ.data[, c("x","y")],radius=spatial.buffer[1],by_point = T)
first.buff<-rangemap::geobuffer_points(occ.data[, c("x","y")],radius=spatial.buffer[1],by_point = T,wrap_antimeridian=T)
data("occ_p", package = "rangemap")
coords <- occ_p[, 2:3]
# buffers
bufferp <- geobuffer_points(data = coords, radius = 25000)
# buffers
bufferp <- rangemap::geobuffer_points(data = coords, radius = 25000)
test_that("Success if temporal method random and spatial random, n.pseudoabs default", {
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
expect_equal(class(results),"data.frame")})
results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01"))
test_that("Success if temporal method random and spatial random, n.pseudoabs default", {
expect_warning(results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01")))
expect_equal(class(results),"data.frame")})
expect_warning(results<-spatiotemp_pseudoabs(occ.data=sample_occ_data,n.pseudoabs=10,temporal.method="random",spatial.method="buffer",spatial.buffer = c(100,1000),temporal.ext=c("2005-01-01","2020-01-01")))
data("sample_occ_data",package="dynamicSDM")
data("sample_model_data")
#skip_if_no_GEE_credentials Skips test_that test if no Google Earth Engine credentials set-up
skip_if_no_GEE_credentials <- function() {
##Import python module
ee <- reticulate::import("ee")
if ((rgee::ee_check_credentials())==F){
skip("No Google Earth Engine credentials available")
}
}
test_that("Works if spatial.ext = polygon and Google Drive used", {
skip_if_no_GEE_credentials()
user.email<-as.character(gargle::gargle_oauth_sitrep()$email)
dates=c("2010-01-01","2010-04-01")
polygon<-sp::Polygon(cbind(c(12,12,36,36),c(-35,-12,-35,-12)))
results<-dynamic_proj_covariates(dates=dates,varnames=c("Temperaturemean","TemperatureEightmean","Precipitationsum","Precipitation8Wsum"),user.email=user.email,drive.folder="temporary_folder_buffered_extraction",
spatial.ext=polygon,spatial.res.degrees=0.05,resample.method="bilinear",
save.drive.folder = "testfiles")
expect_equal(length(results),length(dates))})
dates<-c("2010-01-01","2011-01-01")
Extent<-raster::extent(c(12,36,-35,-12))
#skip_if_no_GEE_credentials Skips test_that test if no Google Earth Engine credentials set-up
skip_if_no_GEE_credentials <- function() {
##Import python module
ee <- reticulate::import("ee")
if ((rgee::ee_check_credentials())==F){
skip("No Google Earth Engine credentials available")
}
}
library(testthat)
test_that("Works if spatial.ext = polygon and Google Drive used", {
skip_if_no_GEE_credentials()
user.email<-as.character(gargle::gargle_oauth_sitrep()$email)
dates=c("2010-01-01","2010-04-01")
polygon<-sp::Polygon(cbind(c(12,12,36,36),c(-35,-12,-35,-12)))
results<-dynamic_proj_covariates(dates=dates,varnames=c("Temperaturemean","TemperatureEightmean","Precipitationsum","Precipitation8Wsum"),user.email=user.email,drive.folder="temporary_folder_buffered_extraction",
spatial.ext=polygon,spatial.res.degrees=0.05,resample.method="bilinear",
save.drive.folder = "testfiles")
expect_equal(length(results),length(dates))})
data("sample_model_data",package ="dynamicSDM")
data("sample_model_data"
)
split = sample(c(TRUE, FALSE), nrow(sample_model_data), replace=TRUE, prob=c(0.75, 0.25))
training = sample_model_data[split, ]
testing = sample_model_data[!split, ]
brt_fit(occ.data=training,
brt_fit(occ.data=training,
test.data=testing,
response.col = "presence.absence",
distribution="bernoulli",
weights.col="sampling_weights",
varnames=colnames(training)[9:12])
brt_fit(occ.data=training,
test.data=testing,
response.col = "presence.absence",
distribution="bernoulli",
weights.col="sampling_weights",
varnames=colnames(training)[9:12])
brt_fit(occ.data=training,
test.data=testing,
response.col = "presence.absence",
distribution="bernoulli",
weights.col="sampling_weights",
varnames=colnames(training)[9:12])
devtools::load_all()
brt_fit(occ.data=training,
brt_fit(occ.data=training,
brt_fit(occ.data=training,
test.data=testing,
response.col = "presence.absence",
distribution="bernoulli"
,
weights.col="sampling_weights",
varnames=colnames(training)[9:12])
devtools::load_all()
devtools::load_all()
devtools::build()
devtools::document()
dynamic_proj_dates(startdate="2000-01-01",enddate="2001-01-01",interval.level = "month",interval=2)
devtools::load_all()
devtools::document()
add_github_actions_check_badge()
install.packages("rcompendium")
rcompendium::add_github_actions_check_badge
rcompendium::add_github_actions_check_badge()
rcompendium::add_github_actions_check()
add_github_actions_check_badge()
rcompendium::add_github_actions_check_badge()
rcompendium::add_github_actions_check()
rcompendium::add_github_actions_check("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")
rcompendium::add_github_actions_check("")
rcompendium::add_github_actions_check_badge()
gert::git_config_global()
devtools::check()
c(rep(1,3),rep(2,3))
data("sample_model_data")
sample_model_data_test<-dplyr::sample_n(sample_model_data,100)
sample_model_data_train<-dplyr::sample_n(sample_model_data,1000)
occ.data = sample_model_data_train
response.col = "presence.absence"
expect_error(brt_fit(occ.data = sample_model_data_train,test.data=sample_model_data_test,response.col = "presence.absence",
arnames=colnames(sample_model_data_train)[9:12]
varnames=colnames(sample_model_data_train)[9:12]
# Remove rows that contain NA in response variable or explanatory variable columns and spatiotemporal blocking/weights column if applicable.
occ.data<-occ.data[,!is.na(occ.data[,response.col])]
occ.data
occ.data[,response.col]
is.na(occ.data[,response.col])
# Remove rows that contain NA in response variable or explanatory variable columns and spatiotemporal blocking/weights column if applicable.
occ.data<-occ.data![,is.na(occ.data[,response.col])]
# Remove rows that contain NA in response variable or explanatory variable columns and spatiotemporal blocking/weights column if applicable.
occ.data<-occ.data-c[,is.na(occ.data[,response.col])]
# Remove rows that contain NA in response variable or explanatory variable columns and spatiotemporal blocking/weights column if applicable.
occ.data<-occ.data[,-c(is.na(occ.data[,response.col]))]
is.na(occ.data[,response.col])
occ.data = sample_model_data_train
occ.data[,response.col]
is.na(occ.data[,response.col])
occ.data[,-c(is.na(occ.data[,response.col]))]
occ.data = sample_model_data_train
# Remove rows that contain NA in response variable or explanatory variable columns and spatiotemporal blocking/weights column if applicable.
occ.data<-occ.data[-c(is.na(occ.data[,response.col])),]
occ.data = sample_model_data_train
# Remove rows that contain NA in response variable or explanatory variable columns and spatiotemporal blocking/weights column if applicable.
occ.data<-occ.data[-c(!is.na(occ.data[,response.col])),]
occ.data
response.col
occ.data<-occ.data[-c(!is.na(occ.data[,varnames])),]
varnames=colnames(sample_model_data_train)[9:12]
occ.data<-occ.data[-c(!is.na(occ.data[,varnames])),]
occ.data<-occ.data[-c(!is.na(occ.data[,varnames])),]
occ.data[,response.col]
# Remove rows that contain NA in response variable or explanatory variable columns and spatiotemporal blocking/weights column if applicable.
occ.data[!is.na(occ.data[,block.col]),]
# Remove rows that contain NA in response variable or explanatory variable columns and spatiotemporal blocking/weights column if applicable.
occ.data[!is.na(occ.data[,response.col]),]
# Remove rows that contain NA in response variable or explanatory variable columns and spatiotemporal blocking/weights column if applicable.
occ.data<-occ.data[!is.na(occ.data[,response.col]),]
occ.data<-occ.data[!is.na(occ.data[,varnames]),]
occ.data
occ.data<-occ.data[!is.na(occ.data[,varnames]),]
occ.data[,varnames])
occ.data[,varnames]
is.na(occ.data[,varnames])
devtools::load_all()
devtools::load_all()
devtools::document()
devtools::build_manual()
devtools::
devtools::check()
